from flask import Flask, request, jsonify, abort
from flask_cors import CORS
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import Configuration, ApiClient, MessagingApi, MessagingApiBlob, ReplyMessageRequest, TextMessage, ImageMessage
from linebot.v3.webhooks import MessageEvent, TextMessageContent, ImageMessageContent, FileMessageContent
from ultralytics import YOLO
import cv2
import os
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"  # 加在程式最頂部
import numpy as np
import io
import tempfile
import pandas as pd
import re
from datetime import datetime
from device_diabetes_analysis_1 import get_therapy_period_index, get_peak_start_time,get_mean_peak_time, plot_low_glucose_events, select_all_low_glucose_events, find_low_glucose_events, cgm_data_download, diabetes_analysis_week, agp_generate, day_conti_chat, diff_time_overlap, diff_time_select_date, generate_cgm_chart, get_cgm_summary, gpt_answer_cgm, gpt_answer_agp, plot_low_glucose_events_window
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib
from basic_function import openai_api_key
from openai import OpenAI
import openai
from werkzeug.utils import secure_filename
import chardet
from upload_patient_0 import upload_patient_info
from device_diabetes_linebot_json import set_profiles, load_profiles, save_profiles, delete_profile
from device_diabetes_csv_data_to_fhir_server_0 import cgm_data_upload
import threading
from device_diabetes_chatbot import create_diabetes_chatbot, dump_memory_to_json, load_conversation_memory, save_conversation_memory, add_to_memory
from device_diabetes_food_chat import food_nutrition_gemini_split, food_nutrition_gemini, annoy_used, food_nutrition_gemini_for_picture_output, food_nutrition_advice_gemini
from device_diabetes_db import create_user_data_db, upload_db_food, search_user_food
from langchain.schema import HumanMessage, AIMessage
import json
from google import genai
from google.genai import types
from sqlalchemy import create_engine, text
import time
from pydub import AudioSegment
import wave
from google.cloud import speech
from google.oauth2 import service_account
matplotlib.use('Agg')  # 非交互式後端
import math
from REST_FUL_API import GET_patient_id_by_name_and_identifier
####################### 設定 LINE Bot 變數設定 ####################
LINE_ACCESS_TOKEN = "J+x3q/VmbRm4u+wgZ+H73n2+ruo7CmvYGTM5p7iMNMZGH2bCAceAoDGOXn43gSq4fswyzWD1St8vARatKEX+GUBx/lpwYpH4vkWB07dLex83X+VQht4DCwbrSdNPm7RKnMFmfz6WV3AC1mzgF3f12QdB04t89/1O/w1cDnyilFU="
LINE_SECRET = "7d308884b15cfc411bf503a21fa8e39f"
ngrok_domain = "https://1545-2001-288-7001-10d7-3444-3d8b-8e99-7e31.ngrok-free.app"
DATABASE_URI = "postgresql+psycopg2://cgm119:A123456789@140.116.156.230:5432/cgm_db"
engine = create_engine(DATABASE_URI)
# 使用全域變數記錄對話狀態與使用者設定
user_chains = {}
# 1. 定義資料夾與檔案路徑
profile    = './linebot_base/line_userid_profile.json'
# 確保 static 資料夾存在
if not os.path.exists('static'):
    os.makedirs('static')
client = genai.Client(api_key="AIzaSyDA8hWMRHGRi8xZUqu_Br_yPJXhpSMjzKE")
####################### YOLO 設定 #######################
# 載入 YOLO 模型
model = YOLO("best11.pt")
# 載入標籤映射
def load_label_map(csv_path="labels.csv"):
    encodings = ["big5","utf-8", "gbk", "latin1"]
    for encoding in encodings:
        try:
            df = pd.read_csv(csv_path, encoding=encoding)
            label_map = dict(zip(df["english_label"], df["chinese_label"]))
            #print(f"成功載入標籤映射（使用編碼: {encoding}）:", label_map)
            return label_map
        except UnicodeDecodeError:
            0
        except FileNotFoundError:
            print(f"找不到 {csv_path}，使用空映射表")
            return {}
        except Exception as e:
            print(f"載入標籤映射時發生錯誤（{encoding}）: {e}")
    print("所有編碼嘗試失敗，使用空映射表")
    return {}
LABEL_MAP = load_label_map("labels.csv")

####################### REPLY Function #######################
# LINE event handlers
def line_reply(configuration, reply_token, messages):
    with ApiClient(configuration) as api_client:
        messaging_api = MessagingApi(api_client)
        messaging_api.reply_message(
            ReplyMessageRequest(
                reply_token=reply_token,
                messages=messages
            )
        )

def food_gemini_picture_reply_flask(image_bytes, text_description=""):
    """
    image_bytes: 圖片的 bytes
    text_description: 可選的文字描述，預設為空字串
    回傳 nutrition_info
    """
    image_part = types.Part.from_bytes(
        data=image_bytes,
        mime_type='image/jpeg',  # 若是 PNG 請改 'image/png'
    )
    prompt = (
        "辨識圖片中的食物名稱可能不會只有一種，與份量(一顆、一碗)與(用g或是ml表示)，"
        "並用以下格式回覆:\n"
        "食物名稱:。\n"
        "份量:。\n"
        "如果判斷不是食物就回覆:圖片中沒有食物"
    )
    if text_description:
        prompt = f"使用者補充描述：{text_description}\n" + prompt

    response = client.models.generate_content(
        model='gemini-2.0-flash',
        contents=[image_part, prompt],
        config=types.GenerateContentConfig(
            temperature=0.1,
            top_p=0.5,
        )
    )
    response_text = response.text
    print("Gemini回應：", response_text)

    food_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    nutrition_info = ""
    if "圖片中沒有食物" not in response_text:
        lines = response_text.strip().split('\n')
        food_pairs = []
        current_name = None
        for line in lines:
            line = line.strip()
            if line.startswith('食物名稱:'):
                current_name = line.replace('食物名稱:', '').strip().rstrip('。')
            elif line.startswith('份量:') and current_name:
                portion = line.replace('份量:', '').strip().rstrip('。')
                food_pairs.append(f"({current_name},{portion})")
                current_name = None
        food_info = ",".join(food_pairs)
        food_item_count = len(food_pairs)
        input_text = f"{food_info},食物項目:{food_item_count}, {food_time},請問營養素含量是多少？"
        print(f"查詢字串: {input_text}")
        pkl_path = "./QA/nutrition_food_v6.pkl"
        df = pd.read_pickle(pkl_path)
        context_index = annoy_used(df)
        nutrition_info = food_nutrition_gemini_for_picture_output(context_index, df, input_text)
    else:
        nutrition_info = "圖片中沒有食物"
    return nutrition_info

def food_gemini_text_reply_flask(user_message):
    """
    user_message: 純文字描述
    回傳 nutrition_info
    """
    split_text = food_nutrition_gemini_split(user_message)
    # 取得 RAG 索引
    pkl_path = "./QA/nutrition_food_v6.pkl"
    df = pd.read_pickle(pkl_path)
    context_index = annoy_used(df)
    input_text = f"{split_text}, 請問營養素含量是多少？"
    nutrition_info = food_nutrition_gemini_for_picture_output(context_index, df, input_text)
    return nutrition_info


####################### APP Flask #######################
app = Flask(__name__)
CORS(app)  # 允許所有來源的跨域請求，測試用
configuration = Configuration(access_token=LINE_ACCESS_TOKEN)
handler = WebhookHandler(LINE_SECRET)
# 上傳資料夾
UPLOAD_DIR = 'uploads_csv'
os.makedirs(UPLOAD_DIR, exist_ok=True)

# 上傳AI食物分析資料夾
AI_FOOD_DIR = 'ai_food'
os.makedirs(AI_FOOD_DIR, exist_ok=True)

@app.route("/")
def home():
    return "CGM LINE Bot 伺服器運行中"

@app.route("/callback", methods=["POST"])
def callback():
    signature = request.headers.get("X-Line-Signature")
    body = request.get_data(as_text=True)
    print("---------------收到 LINE Webhook 請求---------")
    print(f"Webhook 內容: {body}")

    try:
        handler.handle(body, signature)
        print("--------------handler.handle 執行完成-----------------")
    except InvalidSignatureError:
        print("簽名驗證失敗，可能是 Channel Secret 設定錯誤")
        return "Invalid Signature", 400
    except Exception as e:
        print(f"--------------handler.handle 執行時發生錯誤: {e} --------------")
        return "Error", 500

    return "OK", 200

##################################上傳CGM之HTML網站回傳值設置 #########################
#####上傳CGM Flask#####
def background_task(username, user_id, path):
    # 這裡執行耗時的分析
    response = cgm_data_upload(username, user_id, path)
    # 你可以把 response 存到資料庫，或者寫到檔案裡
    app.logger.info(f'分析完成：{response}')

@app.route('/uploadcsv', methods=['POST']) #上傳CGM檔案
def uploadcsv():
    try:
        # 1. 取得表單欄位
        user_id = request.form.get('customId')
        username = request.form.get('username')
        liff_id = request.form.get('userId')
        print(f"測試的liffid為:{liff_id}")
        
        # 2. 基本資料驗證
        if not user_id or not username:
            return jsonify({
                'status': 'error',
                'msg': '缺少必要的使用者資料 (customId 或 username)',
                'details': '請確認已正確填入身分證字號和姓名'
            }), 400
        
        # 3. 檢查使用者是否存在於FHIR伺服器
        print(f"檢查使用者是否存在於FHIR：{username}, {user_id}")
        try:
            patient_id_list = GET_patient_id_by_name_and_identifier(username, user_id)
            patient_id = patient_id_list[0] if patient_id_list else None
            
            if patient_id == "No matching patients found." or patient_id is None:
                return jsonify({
                    'status': 'error',
                    'msg': '使用者資料尚未建立',
                    'details': f'在FHIR伺服器中找不到姓名為「{username}」、身分證字號為「{user_id}」的使用者資料。請先在首頁完成使用者設定。',
                    'suggestion': '請先到首頁進行使用者設定，建立個人資料後再上傳CGM檔案'
                }), 404
            
            if 'Failed to retrieve patient data. Status code:' in patient_id:
                return jsonify({
                    'status': 'error',
                    'msg': 'FHIR伺服器連線失敗',
                    'details': f'無法連接到FHIR伺服器進行使用者驗證：{patient_id}',
                    'suggestion': '請稍後再試，或聯繫系統管理員'
                }), 503
                
            print(f"使用者驗證成功，Patient ID: {patient_id}")
            
        except Exception as fhir_error:
            print(f"FHIR使用者驗證時發生錯誤: {fhir_error}")
            return jsonify({
                'status': 'error',
                'msg': 'FHIR使用者驗證失敗',
                'details': f'驗證使用者時發生錯誤：{str(fhir_error)}',
                'suggestion': '請檢查網路連線或聯繫系統管理員'
            }), 500

        # 4. 取得檔案
        file = request.files.get('file')
        if not file:
            return jsonify({
                'status': 'error',
                'msg': '未收到檔案',
                'details': '請選擇要上傳的CGM CSV檔案'
            }), 400

        # 5. 檔案格式驗證
        if not file.filename.lower().endswith('.csv'):
            return jsonify({
                'status': 'error',
                'msg': '檔案格式錯誤',
                'details': '只接受CSV格式的檔案，請確認檔案副檔名為.csv'
            }), 400

        # 6. 儲存檔案
        filename = os.path.basename(file.filename)
        save_path = os.path.join(UPLOAD_DIR, filename)
        try:
            # 確保上傳目錄存在
            os.makedirs(UPLOAD_DIR, exist_ok=True)
            file.save(save_path)
            print(f"檔案儲存成功：{save_path}")
        except Exception as save_error:
            print(f"檔案儲存失敗: {save_error}")
            return jsonify({
                'status': 'error',
                'msg': f'檔案儲存失敗',
                'details': f'無法儲存檔案到伺服器：{str(save_error)}',
                'suggestion': '請檢查檔案是否完整或聯繫系統管理員'
            }), 500

        # 7. 上傳CGM資料到FHIR
        print(f"開始上傳CGM資料：{username}, {user_id}, {save_path}")
        try:
            response = cgm_data_upload(username, user_id, save_path)
            print(f"CGM上傳回應：{response}")
            
            # 分析上傳結果
            upload_success = False
            upload_details = ""
            
            if "POST 請求成功" in response:
                upload_success = True
                upload_details = "CGM資料已成功上傳到FHIR伺服器"
            elif "所有資料都是重複的" in response:
                upload_success = True
                upload_details = "檔案中的資料已經存在於系統中，無需重複上傳"
            elif "POST 請求失敗" in response:
                upload_details = f"CGM資料上傳失敗：{response}"
            elif "No matching patients found" in response:
                upload_details = "使用者資料驗證失敗，請確認姓名和身分證字號是否正確"
            elif "Failed to retrieve" in response:
                upload_details = "FHIR伺服器連線失敗，請稍後再試"
            else:
                upload_details = f"上傳過程出現未知狀況：{response}"
            
            # 清理暫存檔案（可選）
            try:
                os.remove(save_path)
                print(f"暫存檔案已清理：{save_path}")
            except Exception as cleanup_error:
                print(f"清理暫存檔案時出現錯誤：{cleanup_error}")
            
            # 8. 回傳結果
            if upload_success:
                return jsonify({
                    'status': 'success',
                    'msg': 'CGM檔案上傳成功',
                    'userId': user_id,
                    'username': username,
                    'filename': filename,
                    'upload_details': upload_details,
                    'fhir_response': response
                })
            else:
                return jsonify({
                    'status': 'error',
                    'msg': 'CGM資料上傳失敗',
                    'details': upload_details,
                    'fhir_response': response,
                    'suggestion': '請檢查檔案格式是否正確，或聯繫系統管理員'
                }), 500
                
        except Exception as upload_error:
            print(f"CGM上傳過程中發生錯誤: {upload_error}")
            
            # 清理暫存檔案
            try:
                os.remove(save_path)
            except:
                pass
                
            return jsonify({
                'status': 'error',
                'msg': 'CGM上傳過程發生錯誤',
                'details': f'上傳過程中發生未預期的錯誤：{str(upload_error)}',
                'suggestion': '請檢查檔案內容是否正確，或聯繫系統管理員'
            }), 500
            
    except Exception as e:
        print(f"uploadcsv函數發生未預期錯誤: {e}")
        return jsonify({
            'status': 'error',
            'msg': '系統錯誤',
            'details': f'系統發生未預期錯誤：{str(e)}',
            'suggestion': '請聯繫系統管理員'
        }), 500

@app.route('/ask_user_name_and_id', methods=['POST']) #Flask 輸入user line id 然後回傳fhir name 和 id用於上傳CGM
def ask_user_name_and_id():
    try:
        # 獲取 JSON 請求資料
        data = request.get_json()
        if not data:
            return jsonify({
                'success': False,
                'message': '請提供 JSON 格式的資料'
            }), 400
        
        line_user_id = data.get('userId', '').strip()
        
        if not line_user_id:
            return jsonify({
                'success': False,
                'message': '請提供 userId'
            }), 400
        
        print(f"查詢用戶資料，LINE User ID: {line_user_id}")
        profiles_path = './linebot_base/line_userid_profile.json'
        profiles     = load_profiles(profiles_path)
        if line_user_id not in profiles: 
            return jsonify({
                'success': False,
                'message': '找不到用戶資料，請先設定使用者資料'
            }), 404
        else:
            line_user_profile = profiles.get(line_user_id)
            fhir_name  = line_user_profile.get('patient_name')
            fhir_id    = line_user_profile.get('custom_id')
            print(f"找到用戶：{fhir_name} (身分證字號: {fhir_id})")
            
            # 檢查使用者是否已在FHIR伺服器中
            fhir_status = "未檢查"
            fhir_patient_id = None
            
            try:
                print(f"檢查FHIR伺服器中是否存在用戶：{fhir_name}, {fhir_id}")
                
                # 參考REST_FUL_API.py的設計模式進行FHIR查詢
                patient_id_result = GET_patient_id_by_name_and_identifier(fhir_name, fhir_id)
                
                # 檢查查詢結果
                if isinstance(patient_id_result, list) and len(patient_id_result) > 0:
                    # 檢查是否有有效的patient ID
                    # 根據REST_FUL_API.py，無效結果包含 "No matching patients found." 和 "Failed to retrieve"
                    valid_ids = [pid for pid in patient_id_result if 
                                "No matching patients found" not in str(pid) and 
                                not str(pid).startswith("Failed to retrieve")]
                    
                    if valid_ids:
                        fhir_status = "已連線FHIR伺服器"
                        fhir_patient_id = valid_ids[0]  # 取第一個有效的patient ID
                        print(f"用戶在FHIR伺服器中找到，Patient ID: {fhir_patient_id}")
                    else:
                        # 檢查具體的錯誤類型
                        if any("No matching patients found" in str(pid) for pid in patient_id_result):
                            fhir_status = "尚未建立在FHIR伺服器"
                            fhir_patient_id = "No matching patients found"  # 設定為對應的值
                            print(f"用戶尚未在FHIR伺服器中建立")
                        elif any("Failed to retrieve" in str(pid) for pid in patient_id_result):
                            fhir_status = "FHIR伺服器連線異常"
                            fhir_patient_id = patient_id_result[0]  # 保留完整的錯誤訊息
                            print(f"FHIR伺服器連線失敗: {patient_id_result}")
                        else:
                            fhir_status = "FHIR查詢結果異常"
                            fhir_patient_id = str(patient_id_result)
                            print(f"FHIR查詢回傳未預期的結果: {patient_id_result}")
                else:
                    # 處理非列表回傳或空列表
                    if "No matching patients found" in str(patient_id_result):
                        fhir_status = "尚未建立在FHIR伺服器"
                        fhir_patient_id = "No matching patients found"
                        print(f"用戶尚未在FHIR伺服器中建立")
                    elif "Failed to retrieve" in str(patient_id_result):
                        fhir_status = "FHIR伺服器連線異常"
                        fhir_patient_id = str(patient_id_result)
                        print(f"FHIR伺服器連線失敗: {patient_id_result}")
                    else:
                        fhir_status = "FHIR查詢結果異常"
                        fhir_patient_id = str(patient_id_result)
                        print(f"FHIR查詢回傳未預期的結果: {patient_id_result}")
                    
            except Exception as fhir_error:
                print(f"檢查FHIR伺服器時發生例外錯誤: {fhir_error}")
                fhir_status = "FHIR伺服器連線異常"
                fhir_patient_id = f"Exception: {str(fhir_error)}"
            
            return jsonify({
                'success': True,
                'message': '查詢成功',
                'data': {
                    'patient_name': fhir_name,
                    'custom_id': fhir_id,
                    'fhir_status': fhir_status,
                    'fhir_patient_id': fhir_patient_id
                }
            })
            
    except Exception as e:
        print(f"查詢用戶資料時發生錯誤: {e}")
        return jsonify({
            'success': False,
            'message': f'查詢失敗：{str(e)}'
        }), 500

@app.route('/user_setting', methods=['POST']) #設定用戶ID
def user_setting():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"success": False, "message": "請提供 JSON 格式的資料"}), 400
        
        line_user_id = data.get('line_user_id') or data.get('userId')
        patient_name = data.get('patient_name')
        custom_id = data.get('custom_id')
        birthday = data.get('birthday')
        gender = data.get('gender')
        
        if not line_user_id:
            return jsonify({"success": False, "message": "請提供 line_user_id 或 userId"}), 400
        
        if not patient_name or not custom_id or not birthday or not gender:
            return jsonify({"success": False, "message": "請提供完整的使用者資訊（姓名、身分證字號、生日、性別）"}), 400
        
        # 驗證生日格式
        try:
            datetime.strptime(birthday, '%Y-%m-%d')
        except ValueError:
            return jsonify({"success": False, "message": "生日格式錯誤，請使用 YYYY-MM-DD 格式"}), 400
        
        # 驗證性別
        gender_mapping = {
            '男': 'male',
            '女': 'female',
            'M': 'male',
            'F': 'female',
            'm': 'male',
            'f': 'female',
            'male': 'male',
            'female': 'female'
        }
        
        if gender not in gender_mapping:
            return jsonify({"success": False, "message": "性別格式錯誤，請選擇 男 或 女"}), 400
        
        normalized_gender = gender_mapping[gender]
        
        # 載入現有的用戶資料
        profiles_path = './linebot_base/line_userid_profile.json'
        
        # 如果檔案不存在，建立空的字典
        if os.path.exists(profiles_path):
            profiles = load_profiles(profiles_path)
        else:
            profiles = {}
        
        # 更新或新增用戶資料（參考 set_profiles 格式）
        profiles[line_user_id] = {
            'patient_name': patient_name,
            'custom_id': custom_id,
            'birthday': birthday,       # YYYY-MM-DD 格式
            'gender': normalized_gender  # male 或 female
        }
        
        # 確保目錄存在
        os.makedirs(os.path.dirname(profiles_path), exist_ok=True)
        
        # 儲存更新後的資料
        with open(profiles_path, 'w', encoding='utf-8') as f:
            json.dump(profiles, f, ensure_ascii=False, indent=2)
        
        print(f"用戶資料設定成功：{patient_name} (身分證字號: {custom_id})")
        
        # 上傳使用者資料到 FHIR 伺服器
        try:
            print(f"開始上傳使用者資料到 FHIR 伺服器：{patient_name}, {custom_id}, {birthday}, {normalized_gender}")
            fhir_response = upload_patient_info(patient_name, custom_id, birthday, normalized_gender)
            
            # 建立使用者資料到資料庫
            create_user_data_db(engine, line_user_id, patient_name, custom_id, birthday, normalized_gender)
            
            # 判斷 FHIR 回應狀態
            if "POST 請求成功" in fhir_response:
                fhir_status = "個人資料在 FHIR 伺服器建立完成"
            elif "PUT 請求成功" in fhir_response:
                fhir_status = "FHIR 伺服器已經有此筆資料，已更新"
            else:
                fhir_status = "FHIR 建檔有異常狀況"
                print(f"FHIR 回應: {fhir_response}")
                
        except Exception as fhir_error:
            print(f"FHIR 上傳或資料庫建立時發生錯誤: {fhir_error}")
            fhir_status = "FHIR 建檔發生錯誤"
        
        return jsonify({
            "success": True,
            "message": "用戶資料設定成功",
            "fhir_status": fhir_status,
            "data": {
                "patient_name": patient_name,
                "custom_id": custom_id,
                "birthday": birthday,
                "gender": normalized_gender
            }
        })
        
    except Exception as e:
        print(f"設定用戶資料時發生錯誤: {e}")
        return jsonify({
            "success": False,
            "message": f"設定失敗：{str(e)}"
        }), 500

#####CGM Analysis Flask#####
@app.route('/cgm_analysis', methods=['POST'])
def cgm_analysis():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "請提供 JSON 格式的資料"}), 400

        line_user_id = data.get('line_user_id') or data.get('userId')
        if not line_user_id:
            return jsonify({"error": "請提供 line_user_id 或 userId"}), 400

        request_type = data.get('request_type', 'get_periods')

        print(f"查詢用戶資料，LINE User ID: {line_user_id}")
        profiles_path = './linebot_base/line_userid_profile.json'
        if not os.path.exists(profiles_path):
             return jsonify({"error": f"找不到設定檔: {profiles_path}"}), 500
        
        profiles = load_profiles(profiles_path)
        if line_user_id not in profiles:
            return jsonify({"error": f"找不到用戶資料，請先設定使用者資料"}), 404

        line_user_profile = profiles.get(line_user_id)
        fhir_name = line_user_profile.get('patient_name')
        fhir_id = line_user_profile.get('custom_id')

        if not fhir_name or not fhir_id:
            return jsonify({"error": "用戶設定檔中缺少 fhir_name 或 fhir_id"}), 404
            
        response, total_df, daily_df_dict, total_df_recent, daily_df_dict_recent, therapy_dates_df = cgm_data_download(fhir_name, fhir_id)

        if "No matching patients found" in response or "Failed to retrieve" in response:
            return jsonify({"error": "無法從 FHIR 伺服器讀取 CGM 資料"}), 500

        # 檢查是否有CGM資料
        if total_df.empty or len(daily_df_dict) == 0:
            return jsonify({"error": "尚未上傳任何 CGM 資料，請先上傳 CGM 檔案"}), 404

        if request_type == 'get_periods':
            if therapy_dates_df.empty:
                return jsonify({"therapy_periods": []})

            # 取得每個療程的CGM指標
            therapy_index_df = get_therapy_period_index(total_df, therapy_dates_df)
            # 轉成dict，key用period_index方便合併
            index_dict = {row['period_index']: row for _, row in therapy_index_df.iterrows()}

            # 合併指標到每個period
            therapy_periods = therapy_dates_df.to_dict(orient='records')
            for period in therapy_periods:
                idx = period['period_index']
                if idx in index_dict:
                    period.update({
                        "CGM_Count": index_dict[idx].get("CGM_Count"),
                        "TIR": f"{index_dict[idx].get('TIR', 0)}%",
                        "TAR": f"{index_dict[idx].get('TAR', 0)}%",
                        "TBR": f"{index_dict[idx].get('TBR', 0)}%",
                        "CV": f"{index_dict[idx].get('CGM_CV', 0)}%",
                        "SD": index_dict[idx].get("CGM_StdDev"),
                        "Avg": index_dict[idx].get("CGM_Mean"),
                        "GMI": f"{index_dict[idx].get('GMI', 0)}%"
                    })
            return jsonify({"therapy_periods": therapy_periods})

        elif request_type == 'get_cgm_data':
            period_index = data.get('period_index')
            if period_index is None:
                return jsonify({"error": "缺少 period_index"}), 400
            
            period_info = therapy_dates_df[therapy_dates_df['period_index'] == int(period_index)]
            if period_info.empty:
                return jsonify({"error": "無效的 period_index"}), 400

            start_date = pd.to_datetime(period_info.iloc[0]['start_date'])
            end_date = pd.to_datetime(period_info.iloc[0]['end_date'])

            total_df['datetime'] = pd.to_datetime(total_df['datetime']).dt.tz_localize(None)
            
            period_df = total_df[
                (total_df['datetime'] >= start_date) & 
                (total_df['datetime'] < end_date + pd.Timedelta(days=1))
            ].copy()
            
            if period_df.empty:
                return jsonify({"cgm_data": {'labels': [], 'values': []}})

            period_df = period_df.sort_values('datetime').reset_index(drop=True)
            period_df['datetime_str'] = period_df['datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')
            
            chart_data = {
                'labels': period_df['datetime_str'].tolist(),
                'values': period_df['value'].tolist()
            }
            return jsonify({"cgm_data": chart_data})
        
        elif request_type == 'get_agp':
            period_index = data.get('period_index')
            if period_index is None:
                return jsonify({"error": "缺少 period_index"}), 400
            period_info = therapy_dates_df[therapy_dates_df['period_index'] == int(period_index)]
            if period_info.empty:
                return jsonify({"error": "無效的 period_index"}), 400

            start_date = pd.to_datetime(period_info.iloc[0]['start_date'])
            end_date = pd.to_datetime(period_info.iloc[0]['end_date'])
            total_df['datetime'] = pd.to_datetime(total_df['datetime']).dt.tz_localize(None)
            period_df = total_df[
                (total_df['datetime'] >= start_date) & 
                (total_df['datetime'] < end_date + pd.Timedelta(days=1))
            ].copy()
            if period_df.empty:
                return jsonify({"agp": {"time_labels": [], "mean": [], "p25": [], "p75": [], "p5": [], "p95": []}})

            # 以1分鐘為一格
            period_df['time_bin'] = period_df['datetime'].dt.strftime('%H:%M')
            grouped = period_df.groupby('time_bin')['value']
            agp_mean = grouped.mean()
            agp_p25 = grouped.quantile(0.25)
            agp_p75 = grouped.quantile(0.75)
            agp_p5 = grouped.quantile(0.05)
            agp_p95 = grouped.quantile(0.95)
            time_labels = agp_mean.index.tolist()
            agp_data = {
                'time_labels': time_labels,
                'mean': agp_mean.round(1).tolist(),
                'p25': agp_p25.round(1).tolist(),
                'p75': agp_p75.round(1).tolist(),
                'p5': agp_p5.round(1).tolist(),
                'p95': agp_p95.round(1).tolist()
            }
            return jsonify({"agp": agp_data})
        
        elif request_type == 'get_period_days':
            period_index = data.get('period_index')
            if period_index is None:
                return jsonify({"error": "缺少 period_index"}), 400
            period_info = therapy_dates_df[therapy_dates_df['period_index'] == int(period_index)]
            if period_info.empty:
                return jsonify({"error": "無效的 period_index"}), 400

            start_date = pd.to_datetime(period_info.iloc[0]['start_date'])
            end_date = pd.to_datetime(period_info.iloc[0]['end_date'])
            total_df['datetime'] = pd.to_datetime(total_df['datetime']).dt.tz_localize(None)
            period_df = total_df[
                (total_df['datetime'] >= start_date) & 
                (total_df['datetime'] < end_date + pd.Timedelta(days=1))
            ].copy()
            if period_df.empty:
                return jsonify({"days": []})

            period_df['date'] = period_df['datetime'].dt.strftime('%Y-%m-%d')
            days = []
            for date, group in period_df.groupby('date'):
                values = group['value']
                mean = values.mean()
                sd = values.std()
                tir = 100 * ((values >= 70) & (values <= 180)).sum() / len(values) if len(values) else 0
                tar = 100 * (values > 180).sum() / len(values) if len(values) else 0
                tbr = 100 * (values < 70).sum() / len(values) if len(values) else 0
                days.append({
                    'date': date,
                    'mean': round(mean, 1),
                    'sd': round(sd, 1),
                    'tir': round(tir, 1),
                    'tar': round(tar, 1),
                    'tbr': round(tbr, 1),
                    'count': int(len(values))
                })
            return jsonify({"days": days})
        
        elif request_type == 'get_mean_peak':
            period_index = data.get('period_index')
            if period_index is None:
                return jsonify({"error": "缺少 period_index"}), 400
            # 取得 mean_peak_df，假設有 get_mean_peak_time 函數
            start_time_df = get_peak_start_time(daily_df_dict, therapy_dates_df)
            mean_peak_df = get_mean_peak_time(start_time_df, total_df, 4, ('07:00', '11:00'), ('11:00', '15:00'), ('17:00', '21:00'))
            # 過濾指定 period
            mean_peak_df = mean_peak_df[mean_peak_df['period_index'] == int(period_index)]
            # 轉成 dict list
            result = []
            for _, row in mean_peak_df.iterrows():
                result.append({
                    'period_index': int(row['period_index']),
                    'meal': row['餐別'],
                    'mean_peak_time': float(row['平均達峰時間(分鐘)']),
                    'mean_peak_rise': float(row['平均波動升幅']),
                    'mean_peak_duration': float(row['平均波動持續時間(分鐘)']),
                    'mean_tir': float(row['平均TIR(%)']),
                    'count_le_50': int(row.iloc[4]) if len(row) > 5 else 0,
                    'count_gt_50': int(row.iloc[5]) if len(row) > 6 else 0
                })
            return jsonify({"mean_peak": result})
        
        else:
            return jsonify({"error": "無效的 request_type"}), 400

    except Exception as e:
        print(f"在 /cgm_analysis 中發生錯誤: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"error": f"伺服器內部錯誤: {str(e)}"}), 500

####AI FOOD Flask#####

@app.route('/ai_food_analysis', methods=['POST'])
def ai_food_analysis():
    try:
        print("=== AI 食物分析請求開始 ===")
        
        # 獲取用戶ID
        line_user_id = request.form.get('userId', '').strip()
        if not line_user_id:
            return jsonify({
                'success': False,
                'message': '缺少用戶ID'
            }), 400
        
        # 獲取文字描述
        text_description = request.form.get('textDescription', '').strip()
        print(f"文字描述: {text_description}")
        
        # 獲取語音檔案
        voice_file = request.files.get('voiceFile')
        voice_filename = None
        speech_text = None
        if voice_file:

            timestamp = int(time.time())
            user_id_suffix = line_user_id[-5:] if len(line_user_id) >= 5 else line_user_id
            voice_filename = f"{user_id_suffix}_V_{timestamp}.wav"
            voice_path = os.path.join(AI_FOOD_DIR, voice_filename)
            voice_file.save(voice_path)
            print(f"語音檔案已保存: {voice_filename}")
            # 轉檔成標準 wav
            converted_path = os.path.join(AI_FOOD_DIR, f"converted_{user_id_suffix}_{timestamp}.wav")
            try:
                sound = AudioSegment.from_file(voice_path)
                sound = sound.set_frame_rate(16000).set_channels(1).set_sample_width(2)
                sound.export(converted_path, format="wav")
                print(f"已轉檔為標準 wav: {converted_path}")
                # 取得 sample_rate
                with wave.open(converted_path, 'rb') as wf:
                    sample_rate = wf.getframerate()
                # Google Speech-to-Text 語音辨識
                credentials = service_account.Credentials.from_service_account_file(
                    r"E:\TheSu\NCKU\EHR\pythoncode_v14\igneous-axiom-462710-p0-b4702536bf88.json"
                )
                client = speech.SpeechClient(credentials=credentials)
                with open(converted_path, "rb") as audio_file:
                    content = audio_file.read()
                audio = speech.RecognitionAudio(content=content)
                config = speech.RecognitionConfig(
                    encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
                    sample_rate_hertz=sample_rate,
                    language_code="zh-TW"
                )
                response = client.recognize(config=config, audio=audio)
                recognized_texts = [result.alternatives[0].transcript for result in response.results]
                speech_text = " ".join(recognized_texts)
                print(f"語音辨識結果: {speech_text}")
            except Exception as e:
                print(f"語音辨識失敗: {e}")
                speech_text = None
        
        # 獲取圖片檔案
        image_file = request.files.get('imageFile')
        image_filename = None
        nutrition_info = None
        if image_file:
            # 生成圖片檔案名稱：id後五碼_P_timestamp
            timestamp = int(time.time())
            user_id_suffix = line_user_id[-5:] if len(line_user_id) >= 5 else line_user_id
            file_extension = os.path.splitext(image_file.filename)[1]
            image_filename = f"{user_id_suffix}_P_{timestamp}{file_extension}"
            image_path = os.path.join(AI_FOOD_DIR, image_filename)
            image_file.save(image_path)
            print(f"圖片檔案已保存: {image_filename}")
            image_file.seek(0)  # 重新定位檔案指標
            image_bytes = image_file.read()
            nutrition_info = food_gemini_picture_reply_flask(image_bytes, text_description)
        elif text_description:
            # 只有文字時，呼叫文字分析
            nutrition_info = food_gemini_text_reply_flask(text_description)
        
        # 檢查是否有任何輸入
        if not text_description and not voice_file and not image_file:
            return jsonify({
                'success': False,
                'message': '請提供文字描述、語音或圖片'
            }), 400
        
        # 回傳處理結果
        # 若 nutrition_info 是 list，則用 ***** 分割
        if isinstance(nutrition_info, list):
            nutrition_info_str = '*****'.join(nutrition_info)
        else:
            nutrition_info_str = nutrition_info
        result = {
            'success': True,
            'message': '資料接收成功',
            'data': {
                'user_id': line_user_id,
                'text_description': text_description if text_description else None,
                'voice_filename': voice_filename,
                'image_filename': image_filename,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'speech_text': speech_text,
                'nutrition_info': nutrition_info_str
            }
        }
        print(f"處理結果: {result}")
        return jsonify(result)
        
    except Exception as e:
        print(f"AI 食物分析處理失敗: {e}")
        return jsonify({
            'success': False,
            'message': f'處理失敗：{str(e)}'
        }), 500
    
@app.route('/ai_food_upload_db', methods=['POST'])
def ai_food_upload_db():
    try:
        print("=== AI 食物上傳請求開始 ===")
        data = request.get_json()
        user_id = data.get('userId')
        foods = data.get('foods', [])
        if not user_id or not foods:
            return jsonify({'success': False, 'message': '缺少 userId 或 foods'}), 400

        # 解析每一筆食物，標準化欄位
        parsed_foods = []
        success_count = 0
        fail_count = 0
        fail_messages = []
        for food in foods:
            portion_value = round(float(food.get('portion_value', 1)), 1)
            base_cal = float(food.get('cal', 0))
            base_carb = float(food.get('carb', 0))
            base_pro = float(food.get('pro', 0))
            base_fat = float(food.get('fat', 0))
            cal = round(base_cal * portion_value, 1)
            carb = round(base_carb * portion_value, 1)
            pro = round(base_pro * portion_value, 1)
            fat = round(base_fat * portion_value, 1)
            food_data = {
                'food_name': [food.get('name', '')],
                'food_portion': [food.get('portion', '')],
                'calories': [cal],
                'carbohydrate': [carb],
                'protein': [pro],
                'fat': [fat],
                'date': [food.get('time', '').split(' ')[0] if food.get('time', '') else ''],
                'time': [food.get('time', '').split(' ')[1] if food.get('time', '') and len(food.get('time', '').split(' '))>1 else '']
            }
            parsed_foods.append(food_data)
            # 上傳到資料庫
            success, message = upload_db_food(engine, food_data, user_id)
            if success:
                success_count += 1
            else:
                fail_count += 1
                fail_messages.append(message)

        if success_count > 0 and fail_count == 0:
            response_text = f"成功上傳 {success_count} 筆飲食資訊到資料庫！"
        elif success_count > 0 and fail_count > 0:
            response_text = f"成功上傳 {success_count} 筆飲食資訊，但有 {fail_count} 筆上傳失敗。\n失敗原因：\n" + "\n".join(fail_messages)
        else:
            response_text = f"所有飲食資訊上傳失敗。\n失敗原因：\n" + "\n".join(fail_messages)

        return jsonify({'success': success_count > 0, 'message': response_text, 'foods': parsed_foods})
    except Exception as e:
        return jsonify({'success': False, 'message': f'上傳失敗: {str(e)}'}), 500

@app.route('/food_db_flask', methods=['POST'])
def food_db_flask():
    try:
        
        data = request.get_json()
        user_id = data.get('userId')
        if not user_id:
            return jsonify({'success': False, 'message': '缺少 userId'}), 400
        # 查詢所有飲食資料
        df = search_user_food(engine, user_id)
        if df is None or df.empty:
            return jsonify({'success': True, 'data': []})
        # 依照月份分組，並同一時間多個餐次整合
        df['month'] = df['record_timestamp'].dt.strftime('%Y-%m')
        df['date'] = df['record_timestamp'].dt.strftime('%Y-%m-%d')
        df['time'] = df['record_timestamp'].dt.strftime('%H:%M')
        df['hour'] = df['record_timestamp'].dt.hour
        # 判斷餐別
        def get_meal_type(hour):
            if 5 <= hour < 11:
                return '早餐'
            elif 11 <= hour < 15:
                return '午餐'
            elif 16 <= hour < 20:
                return '晚餐'
            else:
                return '其他'
        df['meal_type'] = df['hour'].apply(get_meal_type)
        # 依日期+時間分組，合併同餐次
        grouped = df.groupby(['month', 'date', 'time', 'meal_type'])
        result = []
        for (month, date, time, meal_type), group in grouped:
            foods = []
            total_carb = 0
            total_pro = 0
            total_fat = 0
            total_carb_portions = 0
            total_cal = 0
            for _, row in group.iterrows():
                foods.append({
                    'food_name': row['food_name'],
                    'food_portion': row['food_portion']
                })
                total_carb += row['carbohydrate'] if not pd.isna(row['carbohydrate']) else 0
                total_pro += row['protein'] if not pd.isna(row['protein']) else 0
                total_fat += row['fat'] if not pd.isna(row['fat']) else 0
                total_carb_portions += row['carb_portions'] if not pd.isna(row['carb_portions']) else 0
                total_cal += row['calories'] if not pd.isna(row['calories']) else 0
            # 防止 NaN 回傳
            def safe_round(val):
                try:
                    if pd.isna(val) or math.isnan(val):
                        return 0
                    return round(val, 1)
                except:
                    return 0
            result.append({
                'month': month,
                'date': date,
                'time': time,
                'meal_type': meal_type,
                'foods': foods,
                'total_cal': safe_round(total_cal),
                'total_carb': safe_round(total_carb),
                'total_pro': safe_round(total_pro),
                'total_fat': safe_round(total_fat),
                'total_carb_portions': safe_round(total_carb_portions)
            })
        # 依月份分組
        from collections import defaultdict
        month_dict = defaultdict(list)
        for item in result:
            month_dict[item['month']].append(item)
        return jsonify({'success': True, 'data': month_dict})
    except Exception as e:
        return jsonify({'success': False, 'message': f'查詢失敗: {str(e)}'}), 500
    
@app.route('/food_delete_db', methods=['POST'])
def food_delete_db():
    try:
        data = request.get_json()
        user_id = data.get('userId')
        date = data.get('date')
        time = data.get('time')
        if not user_id or not date or not time:
            return jsonify({'success': False, 'message': '缺少 userId、date 或 time'}), 400
        # 刪除該 userId 在指定日期時間的所有食物紀錄
        from sqlalchemy import and_
        with engine.begin() as conn:
            delete_sql = text("""
                DELETE FROM food_data
                WHERE line_user_id = :user_id
                  AND to_char(record_timestamp, 'YYYY-MM-DD') = :date
                  AND to_char(record_timestamp, 'HH24:MI') = :time
            """)
            result = conn.execute(delete_sql, {'user_id': user_id, 'date': date, 'time': time})
            deleted_count = result.rowcount
        return jsonify({'success': True, 'message': f'已刪除 {deleted_count} 筆資料'})
    except Exception as e:
        return jsonify({'success': False, 'message': f'刪除失敗: {str(e)}'}), 500

##################################文字輸入處理#########################################
@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    ###########參數設定##########
    print("-----------handle_message觸發--------------")
    line_user_id = event.source.user_id
    user_message = event.message.text
    print(f"來自 {line_user_id} 的訊息: {user_message}")
    profiles_path = './linebot_base/line_userid_profile.json'
    profiles     = load_profiles(profiles_path)
    short_memory = load_conversation_memory(line_user_id)
    # print(f'現在memory內容:\n{short_memory}')

    if line_user_id not in user_chains: ### 如果是第一次，建立一個新的 chain
        print("建立新的user_chain")
        user_chains[line_user_id] = create_diabetes_chatbot(
        api_key=openai_api_key(),
        model_name="gpt-4o-mini-2024-07-18",
        history_k=15,
        system_prompt="你是一個細心且專業的糖尿病營養管理chatbot，盡量簡單扼要地回答使用者，主要的工作是分析患者CGM連續血糖監測數據與其飲食造成的影響。"
        )
    chain = user_chains[line_user_id]

    if line_user_id not in profiles:              #######第一次進行建立，並將建立的資料上傳至FHIR伺服器建檔######
        print("個人資料未建立")
        reply = set_profiles(profiles_path, profiles, line_user_id, user_message)
        if "設定完成" in reply:
            profiles     = load_profiles(profiles_path)
            line_user_profile = profiles.get(line_user_id)
            fhir_name  = line_user_profile.get('patient_name')
            fhir_id    = line_user_profile.get('custom_id')
            fhir_bd    = line_user_profile.get('birthday')
            fhir_gender= line_user_profile.get('gender')
            print(fhir_name,fhir_id,fhir_bd,fhir_gender)
            response = upload_patient_info(fhir_name, fhir_id, fhir_bd, fhir_gender)
            create_user_data_db(engine, line_user_id, fhir_name, fhir_id, fhir_bd, fhir_gender)
            #-------回覆-------
            if "POST 請求成功" in response:
                reply2 = "個人資料在FHIR伺服器建立完成"
            elif"PUT 請求成功" in response:
                reply2 = "FHIR伺服器已經有此筆資料"
            else:
                reply2 = "FHIR建檔有異常狀況"
            messages = [TextMessage(text=reply+'\n'+reply2)]
        else:
            #-------回覆-------
            reply2 = "姓名:\nID:\n生日:\n性別:"
            messages = [TextMessage(text=reply+'\n\n'+"也可以使用下面連結建立使用者資料"),TextMessage(text=reply2),TextMessage(text="https://liff.line.me/2007301708-7r2WyMpB")]
        line_reply(configuration,event.reply_token, messages)

    elif "重新設定使用者資料" in user_message:       #######刪除資料並重新設定使用者名稱######
        print("重新設定使用者資料")
        dele = delete_profile(profiles_path, profiles, line_user_id)
        # reply = set_profiles(profiles_path, profiles, line_user_id, user_message)
        #-------回覆-------
        messages = [TextMessage(text=dele)]
        line_reply(configuration,event.reply_token, messages)

    else:                                         #######已設置過後在這邊######
        ######讀取個人資料#####
        print("--------個人資料已建立--------")
        line_user_profile = profiles.get(line_user_id)
        fhir_name  = line_user_profile.get('patient_name')
        fhir_id    = line_user_profile.get('custom_id')
        fhir_bd    = line_user_profile.get('birthday')
        fhir_gender= line_user_profile.get('gender')
        print("個人資料",fhir_name,fhir_id,fhir_bd,fhir_gender)
        #####設置文字match#####
        cgm_match = re.search(r"分析(\d{4}-\d{2}-\d{2})的CGM", user_message)
        AGP_match = re.search(r"生成AGP報告", user_message)

        if "確認伺服器CGM資料" in user_message:     ####確認CGM資料####
            response, total_cgm_df, daily_cgm_dict, total_cgm_df_recent, daily_cgm_dict_recent, therapy_dates_df = cgm_data_download(fhir_name,fhir_id)
            dates = list(daily_cgm_dict.keys())
            date_str = ", ".join(dates)
            #-------回覆-------
            messages = [TextMessage(text=f"總共有幾天:\n{date_str}")]
            line_reply(configuration,event.reply_token, messages)

        elif cgm_match:    ####分析特定日期CGM資料####
            response, total_df, daily_df_dict, total_df_recent, daily_df_dict_recent, therapy_dates_df = cgm_data_download(fhir_name, fhir_id)
            daily_result_df, difference_warning_df, cgm_stats_str = diabetes_analysis_week(total_df, daily_df_dict, 30, 0.7, 1)   # 第一個數字為變化幅度間隔 #第二為判斷變化幅度(0.6就是60%以上) #第三個為function 0 為前間隔分鐘 1為當日平均做baseline
            overlap_df = diff_time_overlap(difference_warning_df)
            date_str = cgm_match.group(1)
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                print(f"分析 {date_str} 的 CGM 資料")
                summary = get_cgm_summary(total_df, daily_result_df, overlap_df, date_str)
                low_glucose_df, formatted_low_glucose_df = find_low_glucose_events(total_df)
                print("分析完成")
                if "找不到" in summary or "無 Daily Result" in summary:
                    messages = [TextMessage(text="找不到相關CGM數據")]
                else:
                    chart_url = generate_cgm_chart(daily_df_dict, date_str, ngrok_domain)
                    low_glucose_urls = plot_low_glucose_events(formatted_low_glucose_df, total_df, fhir_id, input_date=date_str, ngrok_domain=ngrok_domain)
                    if low_glucose_urls:
                        messages = [TextMessage(text=summary), ImageMessage(original_content_url=chart_url, preview_image_url=chart_url), ImageMessage(original_content_url=low_glucose_urls, preview_image_url=low_glucose_urls)]
                    else:
                        messages = [TextMessage(text=summary), ImageMessage(original_content_url=chart_url, preview_image_url=chart_url)]

                line_reply(configuration,event.reply_token, messages)
                print(f"已回覆 {date_str} 的 CGM 分析和圖表")
                chain.memory.save_context({"input":user_message}, {"output": summary})
            except ValueError:
                messages = [TextMessage(text="日期格式錯誤，請使用 YYYY-MM-DD，例如『分析2025-01-08的CGM』")]
                line_reply(configuration, event.reply_token, messages)
                print(f"已回覆 {date_str} 的 CGM 分析")
            
        elif AGP_match:    #### 生成AGP報告 ####
            summary="AGP摘要回覆如下:"
            response, total_df, daily_df_dict, total_df_recent, daily_df_dict_recent, therapy_dates_df = cgm_data_download(fhir_name, fhir_id)
            daily_result_df, difference_warning_df, cgm_stats_str = diabetes_analysis_week(total_df_recent, daily_df_dict_recent, 30, 0.7, 1)   # 第一個數字為變化幅度間隔 #第二為判斷變化幅度(0.6就是60%以上) #第三個為function 0 為前間隔分鐘 1為當日平均做baseline
            agp_url = agp_generate(fhir_name, fhir_id, total_df_recent, ngrok_domain)
            # agp2_url = day_conti_chat(patient_name,N_id,total_df, ngrok_domain)
            # agp_url = "https://e397-2001-288-7001-10d7-3d04-b4c7-bd49-3645.ngrok-free.app//static/agp_CGM_1192.png"
            #-------回覆圖片-------
            messages = [ImageMessage(original_content_url=agp_url, preview_image_url=agp_url)]
            line_reply(configuration,event.reply_token, messages)
            print(f"已經生成 {fhir_name} 的 AGP報告")
            
        elif "CGM分析與AGP報告" in user_message:
            response, total_df, daily_df_dict ,total_df_recent, daily_df_dict_recent, therapy_dates_df = cgm_data_download(fhir_name, fhir_id)
            daily_result_df, difference_warning_df, cgm_stats_str = diabetes_analysis_week(total_df_recent, daily_df_dict_recent, 30, 0.7, 1)   # 第一個數字為變化幅度間隔 #第二為判斷變化幅度(0.6就是60%以上) #第三個為function 0 為前間隔分鐘 1為當日平均做baseline
            low_glucose_df, formatted_low_glucose_df = find_low_glucose_events(total_df_recent)
            # 防呆機制：檢查是否有低血糖事件
            if formatted_low_glucose_df.empty:
                all_low_glucose_text = "沒有低血糖事件"
                # low_glucose_urls = []
            else:
                all_low_glucose_text = select_all_low_glucose_events(formatted_low_glucose_df)
                # low_glucose_urls = plot_low_glucose_events_window(formatted_low_glucose_df, total_df, fhir_id, input_date=None, ngrok_domain=ngrok_domain)


            gptagp= gpt_answer_agp(f"{cgm_stats_str}\n {all_low_glucose_text}\n 幫我分析這次的AGP報告，不要條列式，盡量口語化簡單易懂讓患者可以正確獲得營養學知識，輸出簡短不要超過50字")
            response_text = "這是你的AGP報告\n"+ gptagp
            agp_url = agp_generate(fhir_name, fhir_id, total_df_recent, ngrok_domain)
            messages = [
                ImageMessage(original_content_url=agp_url, preview_image_url=agp_url),
                TextMessage(text=response_text),
                TextMessage(text=all_low_glucose_text),
                TextMessage(text="如果需要單日的CGM分析 請輸入:分析YYYY-MM-DD的CGM")
            ]
            line_reply(configuration,event.reply_token, messages)
            print(f"已經生成 {fhir_name} 的 AGP報告")

        elif "AI食物辨識與營養分析" in user_message: #會先進行下面的說明，然後改short_memory，強制elif到下面那個情況
            response_text = "可以上傳圖片、或使用文字說明食物種類與份量，或使用下面LIFF介面進行辨識。"
            add_to_memory(line_user_id, response_text)
            messages = [TextMessage(text=response_text),TextMessage(text="https://liff.line.me/2007301708-7r2WyMpB")]
            line_reply(configuration,event.reply_token, messages)
            
        elif short_memory and short_memory[-1]['content'] == "可以上傳圖片、或使用文字說明食物種類與份量，或使用下面LIFF介面進行辨識。":
            ### 食物RAG ###
            pkl_path = "./QA/nutrition_food_v6.pkl"
            df = pd.read_pickle(pkl_path)
            print('df_find')    #取得病歷embedding結果
            context_index = annoy_used(df) # 建立 Annoy 索引
            food_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            input_text = f"{user_message}, 輸入當下參考時間:{food_time}, 請問營養素含量是多少？"
            
            nutrition_info = food_nutrition_gemini(context_index, df, input_text)
            # 格式化營養資訊
            mem_nutrition = f"{nutrition_info}\n有想修正的項目請告訴我，\n如果沒有請輸入:上傳飲食資訊"
            # 儲存到對話記憶
            memory = add_to_memory(line_user_id, mem_nutrition)
            
            #-------回覆-------
            messages = [TextMessage(text=nutrition_info),TextMessage(text="有想修正的項目請告訴我，\n如果沒有請輸入:上傳飲食資訊")]
            line_reply(configuration,event.reply_token, messages)

        elif re.search(r"顯示近[一二三四五六七八九十0-9]+[日天]的?飲食資訊", user_message): #顯示近幾天的飲食紀錄
            # 使用正則表達式提取天數
            days_match = re.search(r"近([一二三四五六七八九十0-9]+)[日天]", user_message)
            if days_match:
                days_str = days_match.group(1)
                # 將中文數字轉換為阿拉伯數字
                chinese_to_arabic = {
                    '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
                    '六': 6, '七': 7, '八': 8, '九': 9, '十': 10
                }
                try:
                    if days_str.isdigit():
                        days = int(days_str)
                    else:
                        days = chinese_to_arabic.get(days_str, 3)  # 如果無法解析，預設為3天
                except ValueError:
                    days = 3  # 如果轉換失敗，預設為3天
                
                # 計算日期範圍
                end_date = (datetime.now() + pd.Timedelta(days=1)).replace(hour=0, minute=0, second=0)  # 改為明天凌晨
                start_date = (end_date - pd.Timedelta(days=days)).replace(hour=0, minute=0, second=0)  # 改為前N天的凌晨
                print(f"查詢日期範圍: {start_date} 至 {end_date- pd.Timedelta(days=1)}")
                
                # 從資料庫查詢指定日期範圍的飲食紀錄
                try:
                    # 使用 search_user_food 函數查詢資料
                    food_records_df = search_user_food(engine, line_user_id, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))
                    
                    if not food_records_df.empty:
                        # 格式化輸出
                        response_text = f"近{days}日({start_date.strftime('%Y-%m-%d')}至{end_date.strftime('%Y-%m-%d')})的飲食紀錄如下:\n\n"
                        # 將 DataFrame 轉換為字典列表，並按時間排序
                        food_records_df = food_records_df.sort_values('record_timestamp', ascending=True)
                        food_records = food_records_df.to_dict('records')
                        for record in food_records:
                            response_text += f"時間: {record['record_timestamp']}\n"
                            response_text += f"食物: {record['food_name']}\n"
                            response_text += f"份量: {record['food_portion']}\n"
                            response_text += f"營養素: 熱量{record['calories']}kcal, 碳水{record['carbohydrate']}g, 蛋白質{record['protein']}g, 脂肪{record['fat']}g\n"
                            response_text += "-------------------\n"
                    else:
                        response_text = f"近{days}日內沒有飲食紀錄。"
                except Exception as e:
                    print(f"查詢飲食紀錄時發生錯誤: {e}")
                    response_text = "查詢飲食紀錄時發生錯誤，請稍後再試。"
            else:
                response_text = "無法解析查詢天數，請使用正確的格式，例如：顯示近三日的飲食紀錄"
            
            messages = [TextMessage(text=response_text)]
            line_reply(configuration, event.reply_token, messages)

        elif "個人飲食建議" in user_message:
            ### 個人飲食建議功能 ###
            pkl_path_ada = "./RAG/standards-of-care-2025.pkl"
            df_ada = pd.read_pickle(pkl_path_ada)
            print('standards-of-care-2025_df_find')
            context_index_ada = annoy_used(df_ada)
            response, total_df ,daily_df_dict ,total_df_recent, daily_df_dict_recent, therapy_dates_df = cgm_data_download(fhir_name, fhir_id)
            start_time_df = get_peak_start_time(daily_df_dict, therapy_dates_df)
            mean_peak_df = get_mean_peak_time(start_time_df, total_df, 4, ('07:00', '11:00'), ('11:00', '15:00'), ('17:00', '21:00'))
            # 取最新period_index（最大值）那一組
            if not mean_peak_df.empty:
                latest_period = mean_peak_df['period_index'].max()
                latest_df = mean_peak_df[mean_peak_df['period_index'] == latest_period]
                # 組成字串
                advice_content = ''
                for _, row in latest_df.iterrows():
                    advice_content += f"{row['餐別']}: (1)平均達峰時間:{row['平均達峰時間(分鐘)']}分鐘 (2)平均波動升幅:{row['平均波動升幅']} mg/dL (3)平均波動持續時間:{row['平均波動持續時間(分鐘)']}分鐘 (4)平均TIR:{row['平均TIR(%)']}%\n"
            else:
                advice_content = ''
            # 使用新的飲食建議函數，將advice_content傳入
            advice_text = food_nutrition_advice_gemini(context_index_ada, df_ada, user_message + '\n個人過去飲食CGM指標：\n' + advice_content, line_user_id)
            #-------回覆-------
            messages = [TextMessage(text=advice_text)]
            line_reply(configuration, event.reply_token, messages)

        elif "上傳飲食資訊" in user_message:
            print("-----上傳飲食資訊觸發-----")
            # 從 short memory 中尋找符合格式的最新飲食記錄
            latest_food_record = None
            for record in reversed(short_memory):  # 從最新的開始往前找
                content = record['content']
                # 檢查是否符合格式（包含所有必要欄位）
                if (re.search(r"\*\*\*\*\*.*\n飲食的時間:", content) and
                    re.search(r"食物名稱:", content) and
                    re.search(r"食物份量:", content) and
                    re.search(r"熱量：", content) and
                    re.search(r"碳水化合物：", content) and
                    re.search(r"蛋白質：", content) and
                    re.search(r"脂肪：", content)):
                    latest_food_record = record
                    break
            
            if latest_food_record: #找到符合格式的最新飲食記錄
                content = latest_food_record['content']
                print(f"找到符合格式的最新飲食記錄: {content}")
                
                # 分割多筆食物記錄
                food_records = []
                current_record = ""
                lines = content.split('\n')
                i = 0
                while i < len(lines):
                    line = lines[i].strip()
                    if line == '*****' or line == '*****  ':
                        if current_record:
                            food_records.append(current_record.strip())
                            current_record = ""
                        i += 1
                        # 跳過空行
                        while i < len(lines) and not lines[i].strip():
                            i += 1
                    else:
                        current_record += lines[i] + '\n'
                        i += 1
                
                # 過濾掉提醒訊息和空記錄
                food_records = [record for record in food_records if record and not record.startswith('提醒您') and not record.startswith('如果沒有其他修正')]
                print(f"過濾掉提醒訊息後的食物記錄: {food_records}")
                
                all_food_data = []
                for record in food_records:
                    # 使用正則表達式提取資訊
                    time_match = re.search(r"飲食的時間:[\s(]*(\d{4}-\d{2}-\d{2} \d{2}:\d{2})[)\s]*", record)
                    food_match = re.search(r"食物名稱:\s*(.*?)(?:\n|$)", record)       
                    portion_match = re.search(r"食物份量:\s*(.*?)(?:\n|$)", record)
                    calories_match = re.search(r"熱量：\s*(\d+\.?\d*)kcal", record)
                    carb_match = re.search(r"碳水化合物：\s*(\d+\.?\d*)g", record)
                    protein_match = re.search(r"蛋白質：\s*(\d+\.?\d*)g", record)
                    fat_match = re.search(r"脂肪：\s*(\d+\.?\d*)g", record)

                    if all([time_match, food_match, portion_match, carb_match, protein_match, fat_match]):
                        # 確保時間格式完整
                        food_data = {
                            "food_name": [food_match.group(1)],
                            "food_portion": [portion_match.group(1)], 
                            "calories": [float(calories_match.group(1))],
                            "carbohydrate": [float(carb_match.group(1))],
                            "protein": [float(protein_match.group(1))],
                            "fat": [float(fat_match.group(1))],
                            "date": [time_match.group(1).split()[0]],
                            "time": [time_match.group(1).split()[1]]
                        }
                        all_food_data.append(food_data)
                
                if all_food_data:
                    success_count = 0
                    fail_count = 0
                    fail_messages = []
                    
                    for food_data in all_food_data:
                        print(f"準備上傳的資料: {food_data}")
                        success, message = upload_db_food(engine, food_data, line_user_id)
                        
                        if success:
                            success_count += 1
                        else:
                            fail_count += 1
                            fail_messages.append(message)
                    
                    if success_count > 0 and fail_count == 0:
                        response_text = f"成功上傳 {success_count} 筆飲食資訊到資料庫！"
                    elif success_count > 0 and fail_count > 0:
                        response_text = f"成功上傳 {success_count} 筆飲食資訊，但有 {fail_count} 筆上傳失敗。\n失敗原因：\n" + "\n".join(fail_messages)
                    else:
                        response_text = f"所有飲食資訊上傳失敗。\n失敗原因：\n" + "\n".join(fail_messages)
                else:
                    response_text = "無法解析任何飲食資訊，請確認格式是否正確。"
                messages = [TextMessage(text=response_text)]    
            else:
                response_text = "近期對話紀錄沒有飲食記錄，可以按照下列格式輸入飲食資訊:。"
                response_text2 = "*****\n飲食的時間: YYYY-MM-DD HH:MM\n食物名稱: 食物名稱\n食物份量: 份量\n熱量：XX.Xkcal\n碳水化合物：XX.Xg\n蛋白質：XX.Xg\n脂肪：XX.Xg\n*****"
                messages = [TextMessage(text=response_text), TextMessage(text=response_text2)]
            line_reply(configuration,event.reply_token, messages)

        else:
            #-------回覆-------
            print("-----else LangChain回覆-----")
            # 將 short memory 轉換為 LangChain 訊息格式
            for memory_entry in short_memory:
                if memory_entry['role'] == 'human':
                    chain.memory.chat_memory.add_user_message(memory_entry['content'])
                else:
                    chain.memory.chat_memory.add_ai_message(memory_entry['content'])
            langchain_input = f'你是一個專業的糖尿病營養師，可能會有糖尿病血糖控制以及飲食營養相關的問題，你要用生活口語的方式回答讓使用者好了解專業內容，同時不要過於條列式也不要回答太長，使用者問題:{user_message}\n\n，根據使用者的問題以及前後對話的內容回答，其他須知:如果問題中有需要修改有關飲食資訊可以建議用之前回覆格式如下，:'
            
            # 用LangChain 回覆
            reply = chain.predict(input=langchain_input) 
            dump_memory_to_json(chain, line_user_id, short_memory)
            messages = [TextMessage(text=reply)]
            line_reply(configuration,event.reply_token, messages)
            




####################### 圖片輸入處理 #######################            
@handler.add(MessageEvent, message=ImageMessageContent)
def handle_image(event):
    print("---------------handle_image() 被觸發--------------------")
    message_id = event.message.id
    line_user_id = event.source.user_id
    print(f"收到來自 {line_user_id} 的圖片訊息，Message ID: {message_id}")
    
    with ApiClient(configuration) as api_client:
        line_bot_blob_api = MessagingApiBlob(api_client)
        message_content = line_bot_blob_api.get_message_content(message_id=message_id)

        image_bytes = message_content
        image_array = np.frombuffer(image_bytes, dtype=np.uint8)
        image = cv2.imdecode(image_array, cv2.IMREAD_COLOR)
        ########### YOLO ########### 
        # if image is None:
        #     print("圖片解碼失敗")
        #     response_text = "無法處理圖片，請再試一次。"
        # else:
        #     results = model.predict(image)
        #     print("辨識結果:", results)

        #     detected_objects = []
        #     for result in results:
        #         for box in result.boxes:
        #             class_id = int(box.cls)
        #             label_en = model.names[class_id]
        #             label_zh = LABEL_MAP.get(label_en, label_en)
        #             confidence = float(box.conf)
        #             print(f"檢測到: 英文標籤={label_en}, 中文標籤={label_zh}, 信心度={confidence}")
        #             detected_objects.append(f"{label_zh}")

        #     if detected_objects:
        #         response_text = "辨識結果如下：\n" + "\n".join(detected_objects) + "\n" +"請問辨識是否有問題?"
                
        #     else:
        #         response_text = "無法辨識圖片中的食物，請再試一次。"
        # response_text = "辨識結果如下：\n" + "三角飯糰" + "\n" +"請問辨識是否有問題?"

        ###########------Gemini--------##########
        image_part = types.Part.from_bytes(
            data=image_bytes,
            mime_type='image/jpeg',  # 若是 PNG 請改 'image/png'
        )
        #1. 呼叫 Gemini generate_content 直接傳入 Part
        response = client.models.generate_content(
            model = 'gemini-2.0-flash',  # model='gemini-2.0-flash', #model = 'gemini-2.5-pro-exp-03-25' , model = 'gemini-2.0-flash-lite'
            contents=[
                image_part,
                "辨識圖片中的食物名稱可能不會只有一種，與份量(一顆、一碗)與(用g或是ml表示)，並用以下格式回覆:\n"
                "食物名稱:。\n"
                "份量:。\n"
                "如果判斷不是食物就回覆:圖片中沒有食物"
            ],
            config=types.GenerateContentConfig(
                # 控制輸出的隨機性，降低值讓食物識別更穩定
                temperature=0.1,
                
                # 控制詞彙選擇的多樣性，較低值更確定性
                top_p=0.5,
                
            )
        )
        print(response.text)
        response_text = response.text
        
        #2. 解析回應文字以獲取食物名稱和份量
        food_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        nutrition_info = ""
        
        if "圖片中沒有食物" not in response_text:
            # 將回應文字按行分割
            lines = response_text.strip().split('\n')
            food_pairs = []
            current_name = None
            
            # 解析每一行
            for line in lines:
                line = line.strip()
                if line.startswith('食物名稱:'):
                    current_name = line.replace('食物名稱:', '').strip().rstrip('。')
                elif line.startswith('份量:') and current_name:
                    portion = line.replace('份量:', '').strip().rstrip('。')
                    food_pairs.append(f"({current_name},{portion})")
                    current_name = None
            
            # 組合所有食物資訊
            food_info = ",".join(food_pairs)
            food_item_count = len(food_pairs)
            input_text = f"{food_info},食物項目:{food_item_count}, {food_time},請問營養素含量是多少？"
            print(f"查詢字串: {input_text}")
            
            ### 食物RAG ###
            pkl_path = "./QA/nutrition_food_v5.pkl"
            df = pd.read_pickle(pkl_path)
            print('df_find')    #取得病歷embedding結果
            context_index = annoy_used(df) # 建立 Annoy 索引
            
            # 生成營養資訊
            nutrition_info = food_nutrition_gemini_for_picture_output(context_index, df, input_text)
            
            # 格式化營養資訊
            mem_nutrition = f"{nutrition_info}\n有想修正的項目請告訴我，\n如果沒有請輸入:上傳飲食資訊"
            # 儲存到對話記憶
            memory = add_to_memory(line_user_id, mem_nutrition)
            print(f"對話記憶: {memory}")
            response_text_2 = nutrition_info
            line_bot_api = MessagingApi(api_client)
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[TextMessage(text=response_text_2), TextMessage(text="有想修正的項目請告訴我，\n如果沒有請輸入:上傳飲食資訊")]
                )
            )
            print("圖片辨識結果已回覆")
        else:
            response_text_2 = "圖片中沒有食物"
            line_bot_api = MessagingApi(api_client)
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[TextMessage(text=response_text_2 )]
                )
            )
            print("圖片辨識結果已回覆")
        #3. 回覆訊息
        #####圖片回覆#####


        
@handler.add(MessageEvent)
def catch_all(event):
    print("-------------收到其他類型的事件----------：", event)



if __name__ == "__main__":
    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']
    plt.rcParams['axes.unicode_minus'] = False
    app.run(port=5000, debug=True)
